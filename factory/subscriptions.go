// Code generated by SQLBoiler boilingfactory-0.1.0 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	models "github.com/zeleniy/test28/models"
)

// This is to force strconv to be used. Without it, it causes an error because strconv is imported by ALL the drivers
var _ = strconv.IntSize

// These packages are needed in SOME models
// This is to prevent errors in those that do not need it
var _ = queries.Query{}

type SubscriptionMod interface {
	Apply(*models.Subscription) error
}

type SubscriptionModFunc func(*models.Subscription) error

func (f SubscriptionModFunc) Apply(n *models.Subscription) error {
	return f(n)
}

type SubscriptionMods []SubscriptionMod

func (mods SubscriptionMods) Apply(n *models.Subscription) error {
	for _, f := range mods {
		err := f.Apply(n)
		if err != nil {
			return err
		}
	}

	return nil
}

func CreateSubscription(mods ...SubscriptionMod) (*models.Subscription, error) {
	return defaultFactory.CreateSubscription(mods...)
}

func (f Factory) CreateSubscription(mods ...SubscriptionMod) (*models.Subscription, error) {
	o := &models.Subscription{}

	baseMod := f.baseSubscriptionMod
	if baseMod != nil {
		err := baseMod.Apply(o)
		if err != nil {
			return nil, err
		}
	}

	err := SubscriptionMods(mods).Apply(o)

	return o, err
}

func CreateSubscriptions(number int, mods ...SubscriptionMod) (models.SubscriptionSlice, error) {
	return defaultFactory.CreateSubscriptions(number, mods...)
}

func (f Factory) CreateSubscriptions(number int, mods ...SubscriptionMod) (models.SubscriptionSlice, error) {
	var err error
	var created = make(models.SubscriptionSlice, number)

	for i := 0; i < number; i++ {
		created[i], err = f.CreateSubscription(mods...)
		if err != nil {
			return nil, err
		}
	}

	return created, nil
}

func InsertSubscription(ctx context.Context, exec boil.ContextExecutor, o *models.Subscription) error {
	return defaultFactory.InsertSubscription(ctx, exec, o)
}

// Inserts the model in the given database
func (f Factory) InsertSubscription(ctx context.Context, exec boil.ContextExecutor, o *models.Subscription) error {
	var err error

	if o == nil {
		return fmt.Errorf("object to save must not be nil")
	}

	var key contextKey = "InsertedSubscription"
	var val string = stringifyVal(o.ID)

	// Check if we have already inserted this model and skip if true
	if inContextKey(ctx, key, val) {
		return nil
	}

	if o.R == nil {
		o.R = o.R.NewStruct()
	}

	if isZero(o.UserID) {
		related, err := f.CreateAndInsertUser(ctx, exec)
		if err != nil {
			return err
		}

		err = SubscriptionWithUser(related).Apply(o)
		if err != nil {
			return err
		}
	}

	err = o.Insert(ctx, exec, boil.Infer())
	if err != nil {
		return err
	}

	// Save in context to ensure we don't enter an infinite loop when adding relationships
	ctx = addToContextKey(ctx, key, val)

	return nil
}

func InsertSubscriptions(ctx context.Context, exec boil.ContextExecutor, objs models.SubscriptionSlice) error {
	return defaultFactory.InsertSubscriptions(ctx, exec, objs)
}

func (f Factory) InsertSubscriptions(ctx context.Context, exec boil.ContextExecutor, objs models.SubscriptionSlice) error {
	for _, o := range objs {
		err := f.InsertSubscription(ctx, exec, o)
		if err != nil {
			return err
		}
	}

	return nil
}

func CreateAndInsertSubscription(ctx context.Context, exec boil.ContextExecutor, mods ...SubscriptionMod) (*models.Subscription, error) {
	return defaultFactory.CreateAndInsertSubscription(ctx, exec, mods...)
}

func (f Factory) CreateAndInsertSubscription(ctx context.Context, exec boil.ContextExecutor, mods ...SubscriptionMod) (*models.Subscription, error) {
	o, err := f.CreateSubscription(mods...)
	if err != nil {
		return nil, err
	}

	err = f.InsertSubscription(ctx, exec, o)

	return o, err
}

func CreateAndInsertSubscriptions(ctx context.Context, exec boil.ContextExecutor, number int, mods ...SubscriptionMod) (models.SubscriptionSlice, error) {
	return defaultFactory.CreateAndInsertSubscriptions(ctx, exec, number, mods...)
}

func (f Factory) CreateAndInsertSubscriptions(ctx context.Context, exec boil.ContextExecutor, number int, mods ...SubscriptionMod) (models.SubscriptionSlice, error) {
	var err error
	var inserted = make(models.SubscriptionSlice, number)

	for i := 0; i < number; i++ {
		inserted[i], err = f.CreateAndInsertSubscription(ctx, exec, mods...)
		if err != nil {
			return nil, err
		}
	}

	return inserted, nil
}

func SubscriptionID(val int) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		o.ID = val
		return nil
	})
}

func SubscriptionIDFunc(f func() (int, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		var err error
		o.ID, err = f()
		return err
	})
}

func SubscriptionUserID(val int) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		o.UserID = val
		return nil
	})
}

func SubscriptionUserIDFunc(f func() (int, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		var err error
		o.UserID, err = f()
		return err
	})
}

func SubscriptionServiceName(val string) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		o.ServiceName = val
		return nil
	})
}

func SubscriptionServiceNameFunc(f func() (string, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		var err error
		o.ServiceName, err = f()
		return err
	})
}

func SubscriptionPrice(val int) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		o.Price = val
		return nil
	})
}

func SubscriptionPriceFunc(f func() (int, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		var err error
		o.Price, err = f()
		return err
	})
}

func SubscriptionStartDate(val time.Time) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		o.StartDate = val
		return nil
	})
}

func SubscriptionStartDateFunc(f func() (time.Time, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		var err error
		o.StartDate, err = f()
		return err
	})
}

func SubscriptionEndDate(val null.Time) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		o.EndDate = val
		return nil
	})
}

func SubscriptionEndDateFunc(f func() (null.Time, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		var err error
		o.EndDate, err = f()
		return err
	})
}

func SubscriptionCreatedAt(val time.Time) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		o.CreatedAt = val
		return nil
	})
}

func SubscriptionCreatedAtFunc(f func() (time.Time, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		var err error
		o.CreatedAt, err = f()
		return err
	})
}

func SubscriptionWithUser(related *models.User) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		if o.R == nil {
			o.R = o.R.NewStruct()
		}

		o.UserID = related.ID
		o.R.User = related

		if related.R == nil {
			related.R = related.R.NewStruct()
		}

		related.R.Subscriptions = append(related.R.Subscriptions, o)
		return nil
	})
}

func SubscriptionWithUserFunc(f func() (*models.User, error)) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		related, err := f()
		if err != nil {
			return err
		}

		return SubscriptionWithUser(related).Apply(o)
	})
}

func SubscriptionWithNewUser(f *Factory, mods ...UserMod) SubscriptionMod {
	return SubscriptionModFunc(func(o *models.Subscription) error {
		if f == nil {
			f = defaultFactory
		}

		related, err := f.CreateUser(mods...)
		if err != nil {
			return err
		}

		return SubscriptionWithUser(related).Apply(o)
	})
}
