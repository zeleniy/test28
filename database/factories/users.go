// Code generated by SQLBoiler boilingfactory-0.1.0 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	models "github.com/zeleniy/test28/internal/models"
)

// This is to force strconv to be used. Without it, it causes an error because strconv is imported by ALL the drivers
var _ = strconv.IntSize

// These packages are needed in SOME models
// This is to prevent errors in those that do not need it
var _ = queries.Query{}

type UserMod interface {
	Apply(*models.User) error
}

type UserModFunc func(*models.User) error

func (f UserModFunc) Apply(n *models.User) error {
	return f(n)
}

type UserMods []UserMod

func (mods UserMods) Apply(n *models.User) error {
	for _, f := range mods {
		err := f.Apply(n)
		if err != nil {
			return err
		}
	}

	return nil
}

func CreateUser(mods ...UserMod) (*models.User, error) {
	return defaultFactory.CreateUser(mods...)
}

func (f Factory) CreateUser(mods ...UserMod) (*models.User, error) {
	o := &models.User{}

	baseMod := f.baseUserMod
	if baseMod != nil {
		err := baseMod.Apply(o)
		if err != nil {
			return nil, err
		}
	}

	err := UserMods(mods).Apply(o)

	return o, err
}

func CreateUsers(number int, mods ...UserMod) (models.UserSlice, error) {
	return defaultFactory.CreateUsers(number, mods...)
}

func (f Factory) CreateUsers(number int, mods ...UserMod) (models.UserSlice, error) {
	var err error
	var created = make(models.UserSlice, number)

	for i := 0; i < number; i++ {
		created[i], err = f.CreateUser(mods...)
		if err != nil {
			return nil, err
		}
	}

	return created, nil
}

func InsertUser(ctx context.Context, exec boil.ContextExecutor, o *models.User) error {
	return defaultFactory.InsertUser(ctx, exec, o)
}

// Inserts the model in the given database
func (f Factory) InsertUser(ctx context.Context, exec boil.ContextExecutor, o *models.User) error {
	var err error

	if o == nil {
		return fmt.Errorf("object to save must not be nil")
	}

	var key contextKey = "InsertedUser"
	var val string = stringifyVal(o.ID)

	// Check if we have already inserted this model and skip if true
	if inContextKey(ctx, key, val) {
		return nil
	}

	if o.R == nil {
		o.R = o.R.NewStruct()
	}

	err = o.Insert(ctx, exec, boil.Infer())
	if err != nil {
		return err
	}

	// Save in context to ensure we don't enter an infinite loop when adding relationships
	ctx = addToContextKey(ctx, key, val)

	if len(o.R.Subscriptions) > 0 {
		for _, related := range o.R.Subscriptions {
			// After inserting, the ID of our current model may have been updated
			// we should updated it in the relations before inserting
			related.UserID = o.ID
			err = f.InsertSubscription(ctx, exec, related)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func InsertUsers(ctx context.Context, exec boil.ContextExecutor, objs models.UserSlice) error {
	return defaultFactory.InsertUsers(ctx, exec, objs)
}

func (f Factory) InsertUsers(ctx context.Context, exec boil.ContextExecutor, objs models.UserSlice) error {
	for _, o := range objs {
		err := f.InsertUser(ctx, exec, o)
		if err != nil {
			return err
		}
	}

	return nil
}

func CreateAndInsertUser(ctx context.Context, exec boil.ContextExecutor, mods ...UserMod) (*models.User, error) {
	return defaultFactory.CreateAndInsertUser(ctx, exec, mods...)
}

func (f Factory) CreateAndInsertUser(ctx context.Context, exec boil.ContextExecutor, mods ...UserMod) (*models.User, error) {
	o, err := f.CreateUser(mods...)
	if err != nil {
		return nil, err
	}

	err = f.InsertUser(ctx, exec, o)

	return o, err
}

func CreateAndInsertUsers(ctx context.Context, exec boil.ContextExecutor, number int, mods ...UserMod) (models.UserSlice, error) {
	return defaultFactory.CreateAndInsertUsers(ctx, exec, number, mods...)
}

func (f Factory) CreateAndInsertUsers(ctx context.Context, exec boil.ContextExecutor, number int, mods ...UserMod) (models.UserSlice, error) {
	var err error
	var inserted = make(models.UserSlice, number)

	for i := 0; i < number; i++ {
		inserted[i], err = f.CreateAndInsertUser(ctx, exec, mods...)
		if err != nil {
			return nil, err
		}
	}

	return inserted, nil
}

func UserID(val int) UserMod {
	return UserModFunc(func(o *models.User) error {
		o.ID = val
		return nil
	})
}

func UserIDFunc(f func() (int, error)) UserMod {
	return UserModFunc(func(o *models.User) error {
		var err error
		o.ID, err = f()
		return err
	})
}

func UserLogin(val string) UserMod {
	return UserModFunc(func(o *models.User) error {
		o.Login = val
		return nil
	})
}

func UserLoginFunc(f func() (string, error)) UserMod {
	return UserModFunc(func(o *models.User) error {
		var err error
		o.Login, err = f()
		return err
	})
}

func UserPasswordHash(val string) UserMod {
	return UserModFunc(func(o *models.User) error {
		o.PasswordHash = val
		return nil
	})
}

func UserPasswordHashFunc(f func() (string, error)) UserMod {
	return UserModFunc(func(o *models.User) error {
		var err error
		o.PasswordHash, err = f()
		return err
	})
}

func UserCreatedAt(val time.Time) UserMod {
	return UserModFunc(func(o *models.User) error {
		o.CreatedAt = val
		return nil
	})
}

func UserCreatedAtFunc(f func() (time.Time, error)) UserMod {
	return UserModFunc(func(o *models.User) error {
		var err error
		o.CreatedAt, err = f()
		return err
	})
}

func UserUUID(val string) UserMod {
	return UserModFunc(func(o *models.User) error {
		o.UUID = val
		return nil
	})
}

func UserUUIDFunc(f func() (string, error)) UserMod {
	return UserModFunc(func(o *models.User) error {
		var err error
		o.UUID, err = f()
		return err
	})
}

func UserWithSubscriptions(related models.SubscriptionSlice) UserMod {
	return UserModFunc(func(o *models.User) error {
		if o.R == nil {
			o.R = o.R.NewStruct()
		}

		o.R.Subscriptions = related

		for _, rel := range related {
			if rel.R == nil {
				rel.R = rel.R.NewStruct()
			}

			rel.UserID = o.ID
			rel.R.User = o
		}

		return nil
	})
}

func UserWithSubscriptionsFunc(f func() (models.SubscriptionSlice, error)) UserMod {
	return UserModFunc(func(o *models.User) error {
		related, err := f()
		if err != nil {
			return err
		}

		return UserWithSubscriptions(related).Apply(o)
	})
}

func UserWithNewSubscriptions(f *Factory, number int, mods ...SubscriptionMod) UserMod {
	return UserModFunc(func(o *models.User) error {
		if f == nil {
			f = defaultFactory
		}

		related, err := f.CreateSubscriptions(number, mods...)
		if err != nil {
			return err
		}

		return UserWithSubscriptions(related).Apply(o)
	})
}

func UserAddSubscriptions(related models.SubscriptionSlice) UserMod {
	return UserModFunc(func(o *models.User) error {
		if o.R == nil {
			o.R = o.R.NewStruct()
		}

		o.R.Subscriptions = append(o.R.Subscriptions, related...)

		for _, rel := range related {
			if rel.R == nil {
				rel.R = rel.R.NewStruct()
			}

			rel.UserID = o.ID
			rel.R.User = o
		}

		return nil
	})
}

func UserAddSubscriptionsFunc(f func() (models.SubscriptionSlice, error)) UserMod {
	return UserModFunc(func(o *models.User) error {
		related, err := f()
		if err != nil {
			return err
		}

		return UserAddSubscriptions(related).Apply(o)
	})
}

func UserAddNewSubscriptions(f *Factory, number int, mods ...SubscriptionMod) UserMod {
	return UserModFunc(func(o *models.User) error {
		if f == nil {
			f = defaultFactory
		}

		related, err := f.CreateSubscriptions(number, mods...)
		if err != nil {
			return err
		}

		return UserAddSubscriptions(related).Apply(o)
	})
}
